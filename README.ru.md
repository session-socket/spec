# Спецификация протокола

### Цель
   
Протокол разработан для взаимодействия двух сторон, 
путем передачи любой бинарной информации в режиме сессии,
которая не зависит от количества соединений и разрывов.

>Пример: применение TCP в мобильной сети, т.к. 
в мобильной сети связь часто бывает не стабильной и 
происходят обрывы соединения

### Условные обозначения
         
* **Сторона отправки**
  
    Все сообщения описываются в формате FIFO,
    т.е. первым в сеть уходит часть справа, последним слева

* **Поля с фиксированным количеством байт**
  
    Размер таких полей имеет строго фиксированный размер
  
    Условное обозначение таких полей: `[name:n]`, где n - число

* **Поля с переменным количеством байт**

  Размер таких полей зависит от 
  предыдущего поля, указывающего размер данных

  Условное обозначение таких полей: `[name:~]`                                               

* **Размер/число с переменным количеством байт**
  
    В спецификации будут встречаться названия полей 
    размеров/чисел с переменным количеством байт для 
    их кодирования. Алгоритм кодирования описан в
    [SQLite4 Variable Length Integers](http://www.sqlite.org/src4/doc/trunk/www/varint.wiki)

    Условное обозначение таких полей: `[name:#]`

### 1. Handshake. Session ID

Первый шаг — синхронизировать состояние сессии.
Для этого стороны должны пройти стадию рукопожатия (handshake). 
Заключается она в обмене специальными данными о сессии
                  
#### Описание полей
`[handshakeCode:1]` код обработки запроса
* `0` - OK
* `1` - версия протокола не поддерживается
* `2` - сессия не существует

`[sessIDSize:#]` размер данных ID сессии
* 0 - новая сессия (со стороны клиента)

`[sessID:~]` данные ID сессии

`[version:1]` версия протокола: 
* `1` - первая версия

#### 1.1. Новая сессия

1. Клиент посылает ID сессии в формате
   
    `[sessIDSize:#][version:1]`
    * `sessIDSize = 0`  0 - запрос на новую сессию
      
2. Сервер принимает ID сессии с размером 0 и отправляет 
    
    `[sessID:~][sessIDSize:#][handshakeCode:1]`
    * `handshakeCode = 0`

#### 1.2. Существующая сессия

1. Клиент посылает ID сессии в формате

   `[sessID:~][sessIDSize:#][version:1]`
    * `sessIDSize != 0`
    
2. Сервер принимает, проверяет существование сессии 
   и отправляет 
   
    `[handshakeCode:1]`
    * `handshakeCode = 0`
    
#### 1.3 Не существующая сессия

1. Клиент посылает ID сессии в формате

   `[sessID:~][sessIDSize:#][version:1]`
    * `sessIDSize != 0`
    
2.  Сервер принимает, проверяет существование сессии,
    не находит ее и отправляет
    
    `[handshakeCode:1]`
    * `handshakeCode=2` 
    
    и через некоторое случайное время должен разорвать 
    соединение
    
#### 1.4 Протокол не поддерживается 

1. На любой из этих запросов 1.1-1.3 от клиента, сервер может
   сообщить, что версия протокола не поддерживается:
   
    `[handshakeCode:1]`
    * `handshakeCode = 1`

    и через некоторое случайное время должен разорвать
    соединение
    
### 2. Exchange data state

Второй шаг — синхронизация состояния передачи данных

1. Клиент отправляет
   
    `[startPacketIndex:#]`
   * `startPacketIndex` глобальный стартовый индекс, 
     с которого надо серверу начать отсчет входящих пакетов. Он
     начинается с нуля и растет с каждым отправленным 
     пакетом (см. п.4)
       
2. Сервер отправляет
    
    `[sessionExpire:1][syncIntervalMax:#][syncIntervalMin:#][startPacketIndex:#]`
    * `startPacketIndex` глобальный стартовый индекс,
      с которого надо клиенту начать отсчет входящих пакетов. Он 
      начинается с нуля и растет с каждым отправленным пакетом
      (см. п.4)
    * `syncIntervalMin` и `syncIntervalMax` минимальный и
      максимальный интервалы синхронизаци пакетов в 
      миллисекундах (см. п.3). Если в течение 
      `syncIntervalMax * 2` нет входящих
      синхронизационных пакетов — соединение считается 
      "мертвым" и его можно закрыть. После закрытия соединения
      начинается отсчет времени не активности сессии.
    * `sessionExpire` время не активности сессии в секундах. Если в
      течение этого времени не было новых соединений с попыткой
      восстановить сессию — сессия может быть удалена сервером
              
### 3. Synchronize packets

Каждый отправленный пакет данных надо хранить в буфере отправки.
Каждый входящий пакет данных увеличивает счетчик в будущем 
синхронизационном пакете на отправку.

Синхронизационный пакет — это пакет, сообщающий другой стороне
сколько пакетов данных было принято от нее. Когда приходит такой 
пакет — это говорит о том, сколько можно пакетов удалить из 
буфера отправки.

Синхронизационный пакет надо отправлять по возможности каждые 
`syncIntervalMin` миллисекунд при количестве больше 0 и каждые 
`syncIntervalMax` миллисекунд при количестве равное 0. Также надо
отправлять синхронизационный пакет при достижении 200 
(значения 201-255 зарезервированы для системных сообщений). 
После отправки синхронизационного пакета — счетчик 
сбрасывается в 0

1. Формат сообщения пакета
    
    `[receiveCount:1][packetSize:#]`
    * `packetSize = 0` 0 - синхронизационный пакет
    * `receiveCount` количество принятых пакетов (1-200)
                                                      
#### 3.1. Heartbeat

В качестве heartbeat пакетов выступает комбинация `[0][0]`

#### 3.2. Session close

Для сообщения другой стороне о необходимости завершения сессии,
надо послать сообщение завершения сессии `[255][0]` и 
_желательно_ ждать ответного сообщения о завершении сессии

### 4. Data packets

Каждый входящий пакет данных должен глобально нумероваться 
внутренней логикой контроллера, для того, что бы на стадии 
синхронизации (см. п.2) понимать, сколько надо пропустить 
входящих пакетов, что бы начать получать новые, т.к. из-за
проблем с сетью, часть пакетов может быть утеряна

>Пример: на момент разрыва, контроллер насчитал 15 входящих 
пакетов данных. При новом соединении, контроллер получает 
`startPacketIndex=10`, т.е. контроллеру необходимо получить и
пропустить 5 пакетов, прежде чем он начнет получать новые

1. Формат сообщения пакета

    `[packetData:~][packetSize:#]`
    * `packetSize > 0` размер данных пакета
    * `packetData` данные пакета
    




    
    









